fn program() -> Vec<i64> {
    vec![
        1, 330, 331, 332, 109, 4078, 1102, 1, 1182, 15, 1102, 1, 1477, 24, 1002, 0, 1, 570, 1006,
        570, 36, 1001, 571, 0, 0, 1001, 570, -1, 570, 1001, 24, 1, 24, 1106, 0, 18, 1008, 571, 0,
        571, 1001, 15, 1, 15, 1008, 15, 1477, 570, 1006, 570, 14, 21101, 0, 58, 0, 1105, 1, 786,
        1006, 332, 62, 99, 21102, 1, 333, 1, 21102, 1, 73, 0, 1106, 0, 579, 1101, 0, 0, 572, 1101,
        0, 0, 573, 3, 574, 101, 1, 573, 573, 1007, 574, 65, 570, 1005, 570, 151, 107, 67, 574, 570,
        1005, 570, 151, 1001, 574, -64, 574, 1002, 574, -1, 574, 1001, 572, 1, 572, 1007, 572, 11,
        570, 1006, 570, 165, 101, 1182, 572, 127, 1001, 574, 0, 0, 3, 574, 101, 1, 573, 573, 1008,
        574, 10, 570, 1005, 570, 189, 1008, 574, 44, 570, 1006, 570, 158, 1105, 1, 81, 21101, 0,
        340, 1, 1106, 0, 177, 21102, 1, 477, 1, 1106, 0, 177, 21101, 514, 0, 1, 21102, 1, 176, 0,
        1105, 1, 579, 99, 21102, 184, 1, 0, 1106, 0, 579, 4, 574, 104, 10, 99, 1007, 573, 22, 570,
        1006, 570, 165, 102, 1, 572, 1182, 21102, 375, 1, 1, 21101, 211, 0, 0, 1106, 0, 579, 21101,
        1182, 11, 1, 21101, 0, 222, 0, 1106, 0, 979, 21102, 388, 1, 1, 21102, 233, 1, 0, 1105, 1,
        579, 21101, 1182, 22, 1, 21101, 0, 244, 0, 1106, 0, 979, 21102, 1, 401, 1, 21102, 255, 1,
        0, 1105, 1, 579, 21101, 1182, 33, 1, 21102, 266, 1, 0, 1105, 1, 979, 21101, 0, 414, 1,
        21101, 277, 0, 0, 1106, 0, 579, 3, 575, 1008, 575, 89, 570, 1008, 575, 121, 575, 1, 575,
        570, 575, 3, 574, 1008, 574, 10, 570, 1006, 570, 291, 104, 10, 21101, 0, 1182, 1, 21102, 1,
        313, 0, 1105, 1, 622, 1005, 575, 327, 1102, 1, 1, 575, 21101, 327, 0, 0, 1105, 1, 786, 4,
        438, 99, 0, 1, 1, 6, 77, 97, 105, 110, 58, 10, 33, 10, 69, 120, 112, 101, 99, 116, 101,
        100, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 110, 97, 109, 101, 32, 98, 117, 116,
        32, 103, 111, 116, 58, 32, 0, 12, 70, 117, 110, 99, 116, 105, 111, 110, 32, 65, 58, 10, 12,
        70, 117, 110, 99, 116, 105, 111, 110, 32, 66, 58, 10, 12, 70, 117, 110, 99, 116, 105, 111,
        110, 32, 67, 58, 10, 23, 67, 111, 110, 116, 105, 110, 117, 111, 117, 115, 32, 118, 105,
        100, 101, 111, 32, 102, 101, 101, 100, 63, 10, 0, 37, 10, 69, 120, 112, 101, 99, 116, 101,
        100, 32, 82, 44, 32, 76, 44, 32, 111, 114, 32, 100, 105, 115, 116, 97, 110, 99, 101, 32,
        98, 117, 116, 32, 103, 111, 116, 58, 32, 36, 10, 69, 120, 112, 101, 99, 116, 101, 100, 32,
        99, 111, 109, 109, 97, 32, 111, 114, 32, 110, 101, 119, 108, 105, 110, 101, 32, 98, 117,
        116, 32, 103, 111, 116, 58, 32, 43, 10, 68, 101, 102, 105, 110, 105, 116, 105, 111, 110,
        115, 32, 109, 97, 121, 32, 98, 101, 32, 97, 116, 32, 109, 111, 115, 116, 32, 50, 48, 32,
        99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 33, 10, 94, 62, 118, 60, 0, 1, 0, -1, -1, 0,
        1, 0, 0, 0, 0, 0, 0, 1, 46, 50, 0, 109, 4, 2102, 1, -3, 586, 21002, 0, 1, -1, 22101, 1, -3,
        -3, 21102, 0, 1, -2, 2208, -2, -1, 570, 1005, 570, 617, 2201, -3, -2, 609, 4, 0, 21201, -2,
        1, -2, 1106, 0, 597, 109, -4, 2106, 0, 0, 109, 5, 1201, -4, 0, 630, 20102, 1, 0, -2, 22101,
        1, -4, -4, 21101, 0, 0, -3, 2208, -3, -2, 570, 1005, 570, 781, 2201, -4, -3, 653, 20102, 1,
        0, -1, 1208, -1, -4, 570, 1005, 570, 709, 1208, -1, -5, 570, 1005, 570, 734, 1207, -1, 0,
        570, 1005, 570, 759, 1206, -1, 774, 1001, 578, 562, 684, 1, 0, 576, 576, 1001, 578, 566,
        692, 1, 0, 577, 577, 21101, 0, 702, 0, 1105, 1, 786, 21201, -1, -1, -1, 1106, 0, 676, 1001,
        578, 1, 578, 1008, 578, 4, 570, 1006, 570, 724, 1001, 578, -4, 578, 21101, 0, 731, 0, 1106,
        0, 786, 1106, 0, 774, 1001, 578, -1, 578, 1008, 578, -1, 570, 1006, 570, 749, 1001, 578, 4,
        578, 21102, 756, 1, 0, 1105, 1, 786, 1106, 0, 774, 21202, -1, -11, 1, 22101, 1182, 1, 1,
        21102, 1, 774, 0, 1106, 0, 622, 21201, -3, 1, -3, 1105, 1, 640, 109, -5, 2106, 0, 0, 109,
        7, 1005, 575, 802, 20101, 0, 576, -6, 21002, 577, 1, -5, 1106, 0, 814, 21102, 1, 0, -1,
        21101, 0, 0, -5, 21102, 0, 1, -6, 20208, -6, 576, -2, 208, -5, 577, 570, 22002, 570, -2,
        -2, 21202, -5, 51, -3, 22201, -6, -3, -3, 22101, 1477, -3, -3, 1201, -3, 0, 843, 1005, 0,
        863, 21202, -2, 42, -4, 22101, 46, -4, -4, 1206, -2, 924, 21101, 1, 0, -1, 1106, 0, 924,
        1205, -2, 873, 21101, 0, 35, -4, 1106, 0, 924, 2102, 1, -3, 878, 1008, 0, 1, 570, 1006,
        570, 916, 1001, 374, 1, 374, 1202, -3, 1, 895, 1101, 0, 2, 0, 2102, 1, -3, 902, 1001, 438,
        0, 438, 2202, -6, -5, 570, 1, 570, 374, 570, 1, 570, 438, 438, 1001, 578, 558, 921, 21002,
        0, 1, -4, 1006, 575, 959, 204, -4, 22101, 1, -6, -6, 1208, -6, 51, 570, 1006, 570, 814,
        104, 10, 22101, 1, -5, -5, 1208, -5, 51, 570, 1006, 570, 810, 104, 10, 1206, -1, 974, 99,
        1206, -1, 974, 1102, 1, 1, 575, 21101, 973, 0, 0, 1106, 0, 786, 99, 109, -7, 2105, 1, 0,
        109, 6, 21102, 0, 1, -4, 21101, 0, 0, -3, 203, -2, 22101, 1, -3, -3, 21208, -2, 82, -1,
        1205, -1, 1030, 21208, -2, 76, -1, 1205, -1, 1037, 21207, -2, 48, -1, 1205, -1, 1124,
        22107, 57, -2, -1, 1205, -1, 1124, 21201, -2, -48, -2, 1106, 0, 1041, 21102, 1, -4, -2,
        1105, 1, 1041, 21101, 0, -5, -2, 21201, -4, 1, -4, 21207, -4, 11, -1, 1206, -1, 1138, 2201,
        -5, -4, 1059, 1202, -2, 1, 0, 203, -2, 22101, 1, -3, -3, 21207, -2, 48, -1, 1205, -1, 1107,
        22107, 57, -2, -1, 1205, -1, 1107, 21201, -2, -48, -2, 2201, -5, -4, 1090, 20102, 10, 0,
        -1, 22201, -2, -1, -2, 2201, -5, -4, 1103, 1202, -2, 1, 0, 1106, 0, 1060, 21208, -2, 10,
        -1, 1205, -1, 1162, 21208, -2, 44, -1, 1206, -1, 1131, 1105, 1, 989, 21102, 1, 439, 1,
        1105, 1, 1150, 21101, 477, 0, 1, 1105, 1, 1150, 21101, 0, 514, 1, 21102, 1, 1149, 0, 1106,
        0, 579, 99, 21102, 1, 1157, 0, 1106, 0, 579, 204, -2, 104, 10, 99, 21207, -3, 22, -1, 1206,
        -1, 1138, 2102, 1, -5, 1176, 2101, 0, -4, 0, 109, -6, 2105, 1, 0, 44, 7, 44, 1, 5, 1, 44,
        1, 5, 1, 44, 1, 5, 1, 44, 1, 5, 1, 44, 1, 5, 1, 40, 11, 40, 1, 3, 1, 42, 9, 42, 1, 3, 1,
        44, 9, 42, 1, 1, 1, 3, 1, 1, 1, 42, 1, 1, 1, 3, 1, 1, 1, 42, 1, 1, 1, 3, 1, 1, 1, 42, 1, 1,
        1, 3, 9, 36, 1, 1, 1, 5, 1, 5, 1, 28, 11, 5, 1, 5, 1, 28, 1, 7, 1, 7, 1, 5, 1, 26, 11, 7,
        1, 5, 1, 26, 1, 1, 1, 15, 1, 5, 1, 26, 1, 1, 1, 15, 7, 26, 1, 1, 1, 38, 9, 1, 1, 1, 1, 38,
        1, 7, 1, 1, 1, 1, 1, 24, 7, 7, 1, 3, 9, 24, 1, 5, 1, 7, 1, 3, 1, 3, 1, 1, 1, 26, 1, 5, 1,
        7, 1, 1, 9, 26, 1, 5, 1, 7, 1, 1, 1, 1, 1, 3, 1, 28, 1, 5, 1, 7, 1, 1, 1, 1, 1, 3, 1, 28,
        1, 5, 1, 7, 1, 1, 1, 1, 1, 3, 1, 28, 9, 5, 1, 1, 1, 1, 1, 3, 13, 22, 1, 1, 1, 5, 1, 1, 1,
        1, 1, 15, 1, 22, 1, 1, 1, 5, 1, 1, 1, 1, 13, 3, 1, 22, 1, 1, 1, 5, 1, 1, 1, 13, 1, 3, 1,
        22, 9, 1, 1, 13, 1, 3, 1, 24, 1, 7, 1, 13, 1, 3, 1, 24, 1, 7, 1, 13, 1, 3, 1, 24, 1, 7, 1,
        13, 1, 3, 1, 24, 9, 9, 9, 46, 1, 50, 9, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1,
        50, 1, 50, 1, 50, 9, 4,
    ]
}

#[derive(Clone, Debug)]
struct Vm<T: Iterator<Item = i64>> {
    data: Vec<i64>,
    ip: usize,
    base: i64,
    input: T,
}

impl<T: Iterator<Item = i64>> Vm<T> {
    fn new(data: Vec<i64>, input: T) -> Self {
        Self {
            data,
            ip: 0,
            base: 0,
            input,
        }
    }

    fn arg_pos(&self, arg: u32) -> usize {
        match self.data[self.ip] / 10_i64.pow(arg + 1) % 10 {
            0 => self.data[self.ip + arg as usize] as usize,
            1 => self.ip + arg as usize,
            2 => (self.data[self.ip + arg as usize] + self.base) as usize,
            m => panic!("Unknown mode {}", m),
        }
    }

    fn get(&self, arg: u32) -> i64 {
        *self.data.get(self.arg_pos(arg)).unwrap_or(&0)
    }

    fn set(&mut self, arg: u32, value: i64) {
        let pos = self.arg_pos(arg);
        if pos >= self.data.len() {
            self.data.resize(pos + 1, 0);
        }
        self.data[pos] = value;
    }

    fn jmp_if(&mut self, cond: bool, a: i64, op_size: usize) {
        if cond {
            self.ip = a as usize;
        } else {
            self.ip += op_size;
        }
    }

    fn inc(&mut self, num: usize) {
        self.ip += num;
    }
}

impl<T: Iterator<Item = i64>> Iterator for Vm<T> {
    type Item = i64;
    fn next(&mut self) -> Option<Self::Item> {
        loop {
            match self.data[self.ip] % 100 {
                01 => (self.set(3, self.get(1) + self.get(2)), self.inc(4)),
                02 => (self.set(3, self.get(1) * self.get(2)), self.inc(4)),
                03 => {
                    let input = self.input.next()?;
                    (self.set(1, input), self.inc(2))
                }
                04 => {
                    let res = self.get(1);
                    self.inc(2);
                    return Some(res);
                }
                05 => (self.jmp_if(self.get(1) != 0, self.get(2), 3), self.inc(0)),
                06 => (self.jmp_if(self.get(1) == 0, self.get(2), 3), self.inc(0)),
                07 => (self.set(3, (self.get(1) < self.get(2)) as i64), self.inc(4)),
                08 => (
                    self.set(3, (self.get(1) == self.get(2)) as i64),
                    self.inc(4),
                ),
                09 => (self.base += self.get(1), self.inc(2)),
                99 => return None,
                xx => panic!("Unexptected opcode {}", xx),
            };
        }
    }
}

fn solve1() -> (usize, Vec<Vec<u8>>) {
    let mut data: Vec<Vec<u8>> = vec![Vec::new()];
    for x in Vm::new(program(), [].iter().copied()) {
        if x == b'\n' as i64 {
            data.push(Vec::new());
        } else {
            data.last_mut().unwrap().push(x as u8);
        }
    }

    for x in &data {
        println!("{}", std::str::from_utf8(&x).unwrap());
    }

    let mut result = 0;
    for y in 1..data.len().saturating_sub(1) {
        for x in 1..data[y].len().saturating_sub(1) {
            if ![(x, y), (x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]
                .iter()
                .any(|(x, y)| data[*y][*x] != b'#')
            {
                result += x * y;
            }
        }
    }

    (result, data)
}

fn prune<'a>(
    mut s: &'a str,
    a: &'a str,
    b: &'a str,
    c: &'a str,
) -> impl Iterator<Item = (&'a str, &'a str)> + 'a {
    std::iter::from_fn(move || {
        if s.starts_with(a) {
            s = &s[a.len()..];
            Some(("A,", s))
        } else if s.starts_with(b) {
            s = &s[b.len()..];
            Some(("B,", s))
        } else if s.starts_with(c) {
            s = &s[c.len()..];
            Some(("C,", s))
        } else {
            None
        }
    })
}

fn solve2(data: Vec<Vec<u8>>) -> usize {
    let mut pos = data
        .iter()
        .enumerate()
        .map(|(y, x)| x.iter().enumerate().map(move |(x, c)| (x, y, *c)))
        .flatten()
        .find(|(_, _, c)| *c == b'^')
        .map(|(x, y, _)| (x as isize, y as isize))
        .unwrap();
    let mut dir = (0, -1);

    let mut instructions = String::new();
    loop {
        let mut try_move = |new_dir: (isize, isize), name: char| {
            let mut length = 0;
            for i in 1.. {
                match data
                    .get((pos.1 + i * new_dir.1) as usize)
                    .and_then(|r| r.get((pos.0 + i * new_dir.0) as usize))
                {
                    Some(c) if *c == b'#' => length = i,
                    _ => break,
                }
            }
            if length > 0 {
                instructions += &format!("{},{},", name, length);
                pos = (pos.0 + length * new_dir.0, pos.1 + length * new_dir.1);
                return Some(new_dir);
            }
            None
        };
        if let Some(new_dir) = try_move((dir.1, -dir.0), 'L') {
            dir = new_dir;
        } else if let Some(new_dir) = try_move((-dir.1, dir.0), 'R') {
            dir = new_dir;
        } else {
            break;
        }
    }
    println!("{}", instructions);

    // Try to find 3 substrings making up the whole
    for i in 1..instructions.len().min(22) {
        let a = &instructions[0..i];
        let a_rest = prune(&instructions[..], a, "Z", "Z").last().unwrap().1;
        for j in 1..a_rest.len().min(22) {
            let b = &a_rest[0..j];
            let b_rest = prune(&instructions[..], a, b, "Z").last().unwrap().1;
            for k in 1..b_rest.len().min(22) {
                let c = &b_rest[0..k];
                let c_rest = prune(&instructions[..], a, b, c).last().unwrap().1;
                if c_rest.is_empty() {
                    let main: String = prune(&instructions[..], a, b, c)
                        .flat_map(|(p, _)| p.chars())
                        .collect();
                    let input = format!(
                        "{}\n{}\n{}\n{}\nn\n",
                        &main[..main.len() - 1],
                        &a[..a.len() - 1],
                        &b[..b.len() - 1],
                        &c[..c.len() - 1]
                    );
                    println!("{}", input);
                    let mut program = program();
                    program[0] = 2;
                    for x in Vm::new(program, input.chars().map(|x| x as i64)) {
                        if x < 255 {
                            print!("{}", x as u8 as char);
                        } else {
                            println!("Result: {}", x);
                        }
                    }
                    break;
                }
            }
        }
    }

    unimplemented!()
}

fn main() {
    let p1 = solve1();
    println!("Part1:\n{}", p1.0);
    println!("Part2:\n{}", solve2(p1.1));
}
